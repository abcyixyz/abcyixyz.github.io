[{"title":"Stm32F407_USB_OTG_HS","url":"/2021/07/01/Stm32F407-USB-OTG-HS/","content":"\n[github progect](https://github.com/abcyixyz/Stm32F407_USB_OTG_HS)\n\n## RT-Thread Studio\n\n---\n\n1. New >> RT-Thread Protect  \n\n![image-20210630223400016](image-20210630223400016.png)\n\n\n\n## CubeMX Settings\n\n---\n\n1. System Core >> RCC >> HSE >> Crystal(外部晶振)  \n2. System Core >> SYS >> Debug(选择调试接口)   \n3. Connectivity >> USART1 >> Asynchronous(用于finsh命令行)  \n4. Connectivity >> USB_OTG_HS >> Host_Only(开发板无供电控制故未勾选VBUS)  \n\n![image-20210630223923547](image-20210630223923547.png)\n\n5. Enable HS global interrupt\n\n![image-20210630223948843](image-20210630223948843.png)\n\n6. Clock Configuration(配置时钟)\n\n   HCLK >> 168  >> Enter\n\n![image-20210630224636418](image-20210630224636418.png)\n\n7. GENERATE COED (default seting)\n\n![image-20210630224256382](image-20210630224256382.png)\n\n![image-20210630224307585](image-20210630224307585.png)\n\n\n\n## Code\n\n---\n\n1. *applications/main.c*\n\n```c\n#define DBG_TAG \"main\"\n//#define DBG_LVL DBG_INFO\n#define DBG_LVL DBG_INFO\n#include <rtdbg.h>\n```\n\n2. *drivers/board.h*\n\n```c\n#define BSP_USING_UART1\n#define BSP_UART1_TX_PIN       \"PA9\"\n#define BSP_UART1_RX_PIN       \"PA10\"\n\n#define BSP_USING_USBHOST\n#define BSP_USBD_TYPE_HS\n```\n\n3. *drivers/drv_clk.c* (copy from *cubemx/Src/main.c*)\n\n```c\nvoid SystemClock_Config(void)\n{\n  RCC_OscInitTypeDef RCC_OscInitStruct = {0};\n  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};\n\n  /** Configure the main internal regulator output voltage\n  */\n  __HAL_RCC_PWR_CLK_ENABLE();\n  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);\n  /** Initializes the RCC Oscillators according to the specified parameters\n  * in the RCC_OscInitTypeDef structure.\n  */\n  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;\n  RCC_OscInitStruct.HSEState = RCC_HSE_ON;\n  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;\n  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;\n  RCC_OscInitStruct.PLL.PLLM = 25;\n  RCC_OscInitStruct.PLL.PLLN = 336;\n  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;\n  RCC_OscInitStruct.PLL.PLLQ = 7;\n  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)\n  {\n    Error_Handler();\n  }\n  /** Initializes the CPU, AHB and APB buses clocks\n  */\n  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK\n                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;\n  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;\n  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;\n  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;\n  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;\n\n  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)\n  {\n    Error_Handler();\n  }\n}\n\n//void system_clock_config(int target_freq_mhz)\n//{\n//...\n//}\n```\n\n4. new source file  \n\n![image-20210630224927209](image-20210630224927209.png)\n\n5. `applications/filesystem.c`\n\n```C\n#include <rtthread.h>\n#include <dfs_fs.h>\n#include \"dfs_romfs.h\"\n\n#define DBG_TAG \"app.filesystem\"\n#define DBG_LVL DBG_INFO\n#include <rtdbg.h>\n\nstatic const struct romfs_dirent _romfs_root[] = {\n    {ROMFS_DIRENT_DIR, \"udisk\", RT_NULL, 0}\n};\n\nconst struct romfs_dirent romfs_root = {\n    ROMFS_DIRENT_DIR, \"/\", (rt_uint8_t *)_romfs_root, sizeof(_romfs_root) / sizeof(_romfs_root[0])\n};\n\nint mount_init(void)\n{\n    if (dfs_mount(RT_NULL, \"/\", \"rom\", 0, &(romfs_root)) != 0)\n    {\n        LOG_E(\"rom mount to '/' failed!\");\n        return RT_ERROR;\n    }\n    return RT_EOK;\n}\nINIT_APP_EXPORT(mount_init); \n```\n\n6. drivers/drv_common.c\n\n[STM32F407遇到USB读取U盘无法读取问题](https://club.rt-thread.org/ask/question/427531.html)\n\n```C\nvoid HAL_Delay(__IO uint32_t Delay)\n{\n    rt_thread_mdelay(Delay);\n}\n```\n\n7. drivers/drv_usbh.c\n\n```c\n#define DBG_TAG \"drv_usbh\"\n#define DBG_LVL DBG_LOG\n#include <rtdbg.h>\n\n/* add OTG_HS_IRQ */\nvoid OTG_HS_IRQHandler(void)\n{\n    rt_interrupt_enter();\n    HAL_HCD_IRQHandler(&stm32_hhcd_fs);\n    rt_interrupt_leave();\n}\n\n/* cubemx/Src/main.c >> static void MX_USB_OTG_HS_HCD_Init(void) */\n#ifdef BSP_USBD_TYPE_HS\nstatic rt_err_t stm32_hcd_init(rt_device_t device)\n{\n    HCD_HandleTypeDef *hhcd = (HCD_HandleTypeDef *)device->user_data;\n    hhcd->Instance = USB_OTG_HS;\n    hhcd->Init.Host_channels = 12;\n    hhcd->Init.speed = HCD_SPEED_FULL;\n    hhcd->Init.dma_enable = DISABLE;\n    hhcd->Init.phy_itface = USB_OTG_EMBEDDED_PHY;\n    hhcd->Init.Sof_enable = DISABLE;\n    hhcd->Init.low_power_enable = DISABLE;\n    hhcd->Init.vbus_sensing_enable = DISABLE;\n    hhcd->Init.use_external_vbus = DISABLE;\n    RT_ASSERT(HAL_HCD_Init(hhcd) == HAL_OK);\n    HAL_HCD_Start(hhcd);\n#ifdef USBH_USING_CONTROLLABLE_POWER\n    rt_pin_mode(USBH_POWER_PIN, PIN_MODE_OUTPUT);\n    rt_pin_write(USBH_POWER_PIN, PIN_LOW);\n#endif\n    return RT_EOK;\n}\n\n#else\n\nstatic rt_err_t stm32_hcd_init(rt_device_t device)\n{\n    HCD_HandleTypeDef *hhcd = (HCD_HandleTypeDef *)device->user_data;\n    hhcd->Instance = USB_OTG_FS;\n    hhcd->Init.Host_channels = 8;\n    hhcd->Init.speed = HCD_SPEED_FULL;\n    hhcd->Init.dma_enable = DISABLE;\n    hhcd->Init.phy_itface = HCD_PHY_EMBEDDED;\n    hhcd->Init.Sof_enable = DISABLE;\n    RT_ASSERT(HAL_HCD_Init(hhcd) == HAL_OK);\n    HAL_HCD_Start(hhcd);\n#ifdef USBH_USING_CONTROLLABLE_POWER\n    rt_pin_mode(USBH_POWER_PIN, PIN_MODE_OUTPUT);\n    rt_pin_write(USBH_POWER_PIN, PIN_LOW);\n#endif\n    return RT_EOK;\n}\n#endif\n```\n\n\n\n## RT-Thread Settings\n---\n\n1. Exclude from Build\n\n~~cubemx/Src/main.c~~  \n~~cubemx/Src/stm32f4xx_it.c~~  \n\n![image-20210630224537429](image-20210630224537429.png)\n\n![image-20210630225754496](image-20210630225754496.png)\n\n2. Components >> Device Drivers >> Using USB >> Using USB host >> Enable Udisk Drivers >> Udisk mount dir >> /udisk\n\n![image-20210630225432224](image-20210630225432224.png)\n\n3. Components >> Device virtual file system >> Using device virtual file system >> Enable elm-chan fatfs  /  Enable ReadOnlay file system on flash\n\n![image-20210630225517213](image-20210630225517213.png)\n\n## Test\n\n---\n1. Build and Flash download\n2. Terminal\n\n<kbd>Ctrl</kbd>+<kbd>Atl</kbd>+<kbd>Shift</kbd> +<kbd>T</kbd>\n\n![image-20210630225624874](image-20210630225624874.png)\n\n3. Insert the u-disk(插入U盘)\n\n![image-20210630225644852](image-20210630225644852.png)\n\n## End","tags":["stm32 usb-otg-hs u-disk rt-thread studio"]},{"title":"Archlinux下rCore 实验环境配置","url":"/2021/03/21/Archlinux下rCore-实验环境配置/","content":"Archlinux下rCore 实验环境配置\n\n原文：[rCore-Tutorial-Book 第三版 实验环境配置](https://rcore-os.github.io/rCore-Tutorial-Book-v3/chapter0/5setup-devel-env.html#rust)\n\n+ 系统环境配置（使用Archlinux）\n+ Rust开发环境配置\n+ Qemu模拟器安装\n+ GDB 调试支持\n\n## Rust 开发环境配置\n\n首先安装Rust包管理器cargo和Rust版本管理器rustup\n\n```bash\nsudo pacman -S cargo\nsudo pacman -S rustup\n```\n\n修改Rust Crates源 [ustc](https://mirrors.ustc.edu.cn/help/crates.io-index.html)，在 `$HOME/.cargo/config` 中添加如下内容：\n\n```bash\n[source.crates-io]\nreplace-with = 'ustc'\n\n[source.ustc]\nregistry = \"git://mirrors.ustc.edu.cn/crates.io-index\"\n```\n\n可通过如下命令安装rustc的nightly版本（rCore要求用rustc的nightly版本），并把该版本设置为rustc的缺省版本\n\n```bash\nrustup install nightly\nrustup default nightly\n```\n\n接下来安装一些Rust相关的软件包\n\n```bash\nrustup target add riscv64gc-unknown-none-elf\ncargo install cargo-binutils\nrustup component add llvm-tools-preview\nrustup component add rust-src\n```\n\n## Qemu 模拟器安装\n\n```bash\nsudo pacman -S qemu-arch-extra\n```\n\n随后即可在当前终端 `source ~/.bashrc` 更新系统路径，或者直接重启一个新的终端。此时我们可以确认 Qemu 的版本\n\n```bash\nqemu-system-riscv64 --version\nqemu-riscv64 --version\n```\n\n## GDB 调试支持\n\n在 `os` 目录下 `make debug` 可以调试我们的内核，这需要安装终端复用工具 `tmux` ，还需要基于 riscv64 平台的 gdb 调试器 `riscv64-unknown-elf-gdb` 。该调试器包含在 riscv64 gcc 工具链中。\n\n```bash\nyay -S riscv64-unknown-elf-gdb\n```\n\n## 运行 rCore-Tutorial-v3\n\n如果是在 Qemu 平台上运行，只需在`os`目录下 `make run` 即可。在内核加载完毕之后，可以看到目前可以用的 应用程序。 `usertests` 打包了其中的很大一部分，所以我们可以运行它，只需输入在终端中输入它的名字即可。运行后，可以先按下 `Ctrl+A` ，再按下 `X` 来退出 Qemu。","tags":["rCore Rust Qemu GDB Archlinux"]},{"title":"Mosquitto 搭建及配置","url":"/2021/03/21/Mosquitto-搭建及配置/","content":"# Mosquitto 搭建及配置\n\nEclipse Mosquitto是一个开源消息代理，实现了MQTT协议版本3.1和3.1.1。Mosquitto轻量，适用于低功耗单板计算机到完整服务器的所有设备。Mosquitto项目还提供了用于实现MQTT客户端的C库以及非常受欢迎的mosquitto_pub和mosquitto_sub命令行MQTT客户端。\n\n其他服务器代理实现:https://github.com/mqtt/mqtt.github.io/wiki/servers\n 各操作系统安装指引:https://mosquitto.org/download/\n\n#### 1. 下载安装\n\n以Ubuntu为例\n\n- 更新源\n\n```bash\nsudo apt-get update\n```\n\n- 安装服务器端\n\n```bash\nsudo apt-get install mosquitto\n```\n\n+ 安装客户端\n\n```bash\nsudo apt-get install mosquitto-clients\n```\n\n#### 2. 配置\n\n##### 2.1 主配置文件mosquitto.conf\n\n```nginx\nid_file /var/run/mosquitto.pid\n\n# 消息持久存储\npersistence true\npersistence_location /var/lib/mosquitto/\n\n# 日志文件\nlog_dest file /var/log/mosquitto/mosquitto.log\n\n# 其他配置\ninclude_dir /etc/mosquitto/conf.d\n\n# 禁止匿名访问\nallow_anonymous false\n# 认证配置\npassword_file /etc/mosquitto/pwfile\n# 权限配置\nacl_file /etc/mosquitto/aclfile\n```\n\n##### 2.2 认证配置pwfile\n\n- 创建密码存储文件\n\n```bash\nsudo touch /etc/mosquitto/pwfile\n```\n\n- 服务开启后,输入如下命令,根据提示输入两遍密码\n\n```bash\nmosquitto_passwd /etc/mosquitto/pwfile 用户名\n```\n\n##### 2.3 权限配置aclfile\n\n- 打开文件\n\n```bash\nvim /etc/mosquitto/aclfile\n```\n\n- 编辑内容\n\n```nginx\n# 李雷只能发布以test为前缀的主题,订阅以$SYS开头的主题即系统主题\nuser lilei\ntopic write test/#\ntopic read $SYS/#\n\n# 韩梅梅只能订阅以test为前缀的主题\nuser hanmeimei\ntopic read test/#\n```\n\n#### 3. 启动\n\n-c：指定特定配置文件启动\n-d：后台运行\n\n```bash\nmosquitto -c /etc/mosquitto/mosquitto.conf -d\n```\n\n#### 4. 测试\n\n发布使用mosquitto_pub命令，订阅使用mosquitto_sub命令。常用参数介绍：\n\n| 参数 | 描述                      |\n| ---- | ------------------------- |\n| -h   | 服务器主机，默认localhost |\n| -t   | 指定主题                  |\n| -u   | 用户名                    |\n| -P   | 密码                      |\n| -i   | 客户端id，唯一            |\n| -m   | 发布的消息内容            |\n\n订阅\n\n```bash\nmosquitto_sub -h localhost -t \"test/#\" -u hanmeimei -P 123456 -i \"client1\"\n```\n\n订阅系统主题\n\n```bash\n# 订阅客户端存活连接数\nmosquitto_sub -h localhost –t '$SYS/broker/clients/active' -u lilei -P 123456 -i \"client2\"\n```\n\n发布\n\n```bash\nmosquitto_pub -h localhost -t \"test/abc\" -u lilei -P 123456 -i \"client3\" -m \"How are you?\"\n```\n\n##### 链接\n\n- 项目网站：https://www.eclipse.org/paho\n- Eclipse项目信息：https://projects.eclipse.org/projects/iot.paho\n- GitHub：https://github.com/eclipse/paho.mqtt.java\n- MQTT Java客户端的使用：https://www.jianshu.com/p/65e1748a930c\n- Spring支持：https://www.jianshu.com/p/6b60858b7d44","tags":["mqtt server"]},{"title":"Gitblit 安装使用","url":"/2020/11/22/Gitblit-安装使用/","content":"\n[Gitblit](https://gitblit.github.io/gitblit/) is an open-source, pure Java stack for managing, viewing, and serving Git repositories.\nIt's designed primarily as a tool for small workgroups who want to host centralized repositories.\n\n Gitblit是一个在Java环境中运行的Git服务器。在这里记录一下搭建过程。\n\n# 准备文件\n\n* jdk-11.0.2_windows-x64_bin.zip[华为源](https://repo.huaweicloud.com/java/jdk/)\n* gitblit安装包[Gitblit](https://gitblit.github.io/gitblit/)\n\n# 安装Java\n请参考[菜鸟教程](https://www.runoob.com/java/java-environment-setup.html)\n\n# 配置Gitblit\n1. 下载的zip文件只要解压缩即可，不用安装。建议放到D:\\Program Files\\gitblit-xxx目录中（xxx指版本号）\n2. 新建一个用于存放git服务器数据的文件夹，如D:\\GitBlit_repository\n3. 配置gitblit.properties 文件。  \n    * 在D:\\Program Files\\gitblit-xxx\\data目录中将defaults.properties文件复制一份，改名为my.properties  \n    * 修改gitblit.properties文件，然后将 `include = defaults.properties` 注释掉  \n    * 添加一代码`include = my.properties`表示使用my.properties这个配置。  \n4. 修改my.properties文件中的端口和服务器IP地址：  \n    * 修改git.repositoriesFolder = D:/Gitblit_repository（注意其中的D:\\Gitblit_repository 中的\"\\\"一定要用\"/\"。）  \n    * 修改server.httpPort = 10101  \n    * 修改server.httpBindInterface = 192.168123.15（我自己的服务器IP地址为192.168.123.15）  \n    * 修改server.httpsBindInterface = localhost  \n    * 最后修改server.certificateAlias = localhost\n5. 运行Gitblit服务。在D:\\Program Files\\gitblit-xxx目录下运行gitblit.cmd命令。注意看命令行中的提示，检查程序是否运行正常。\n6. 命令行中会有服务器ip和端口号请注意查看。\n\n# 管理GitBlit\n在浏览器地址栏中输入命令行中提示的服务器ip和端口号\n如果成功加载，说明服务器搭建完毕。默认账号密码均为admin\n\n# 设置开启自启动\n设置以Windows Service方式启动Gitblit.  \n1. 在Gitblit目录下，找到installService.cmd文件。鼠标右键使用记事本打开。  \n2. 设置 CD 为程序目录 `SET CD=D:\\Program Files\\gitblit-xxx(xxx修改为你自己的目录)`  \n3. 保存，关闭文件\n4. 右键installService.cmd文件，选择以管理员的身份运行  \n5. 点击开始菜单输入services.msc 打开Windows服务查找gitblit，如果未启动，请手动启动。注意确保为自动模式，这样每次windows启动后都自动启动此项服务。","tags":["Gitblit Windows git server 局域网"]},{"title":"Hello World","url":"/2020/05/24/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]